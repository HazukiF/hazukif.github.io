<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hazuki — Shadow Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,400&family=DM+Sans:wght@300;400;500&family=Noto+Sans+JP:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
</head>
<body>

    <header class="animate-in">
        <a href="index.html" class="site-title">Hazuki <span class="jp">シャドウ・ポートフォリオ</span></a>
        <nav>
            <a href="index.html" class="active">Portfolio</a>
            <a href="#">Theses</a>
            <a href="#">Models</a>
            <a href="about.html">About</a>
        </nav>
    </header>

    <hr class="divider">

    <!-- Portfolio Summary -->
    <section class="portfolio-hero animate-in delay-1">
        <div class="portfolio-label">Portfolio Value <span class="portfolio-label-jp">運用総額</span></div>
        <div class="portfolio-hero-inner">
            <div class="portfolio-value" id="portfolio-value">—</div>
            <div class="portfolio-return" id="portfolio-return">—</div>
        </div>
        <div class="portfolio-meta" id="portfolio-meta">Loading...</div>
    </section>

    <!-- Key Stats -->
    <div class="stats-row animate-in delay-2">
        <div class="stat-card">
            <div class="stat-label">YTD Return</div>
            <div class="stat-value" id="stat-ytd">—</div>
            <div class="stat-sub" id="stat-ytd-bench">—</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Sharpe Ratio</div>
            <div class="stat-value" id="stat-sharpe">—</div>
            <div class="stat-sub">Annualized</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Max Drawdown</div>
            <div class="stat-value" id="stat-drawdown">—</div>
            <div class="stat-sub" id="stat-drawdown-date">—</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Positions</div>
            <div class="stat-value" id="stat-positions">—</div>
            <div class="stat-sub" id="stat-positions-breakdown">—</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Cash</div>
            <div class="stat-value" id="stat-cash-pct">—</div>
            <div class="stat-sub" id="stat-cash-usd">—</div>
        </div>
    </div>

    <!-- Performance Chart -->
    <section class="chart-section animate-in delay-3">
        <div class="chart-header">
            <div class="chart-title">Cumulative Return <small>累積リターン</small></div>
            <div class="time-filters">
                <button class="time-btn" data-range="1m">1M</button>
                <button class="time-btn" data-range="3m">3M</button>
                <button class="time-btn" data-range="6m">6M</button>
                <button class="time-btn active" data-range="1y">1Y</button>
                <button class="time-btn" data-range="all">ALL</button>
            </div>
        </div>
        <div class="chart-container">
            <canvas id="performanceChart"></canvas>
        </div>
        <div class="chart-legend">
            <div class="legend-item"><div class="legend-dot" style="background: #2D5A3D;"></div>Portfolio</div>
            <div class="legend-item"><div class="legend-dot" style="background: #C4C4C4;"></div>Nikkei 225</div>
            <div class="legend-item"><div class="legend-dot" style="background: #D4C4A8;"></div>S&P 500</div>
        </div>
    </section>

    <hr class="divider">

    <!-- Holdings Table -->
    <section class="holdings-section animate-in delay-4">
        <div class="holdings-header">
            <div class="holdings-title">Current Holdings <small>保有銘柄</small></div>
            <div class="holdings-count" id="holdings-count">—</div>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Ticker</th>
                    <th>Sector</th>
                    <th>Weight</th>
                    <th>Avg Cost</th>
                    <th>Current</th>
                    <th>Return</th>
                </tr>
            </thead>
            <tbody id="holdings-body">
                <tr><td colspan="6" style="text-align:center; color:var(--text-tertiary); padding:2rem;">Loading portfolio data...</td></tr>
            </tbody>
        </table>
    </section>

    <hr class="divider">

    <!-- Allocation Breakdown -->
    <section class="allocation-grid">
        <div class="allocation-card">
            <div class="allocation-card-title">Geography <span class="jp" style="font-size:0.6rem; font-weight:300; color:var(--text-tertiary);">地域配分</span></div>
            <div id="geo-allocation">Loading...</div>
        </div>
        <div class="allocation-card">
            <div class="allocation-card-title">Sector <span class="jp" style="font-size:0.6rem; font-weight:300; color:var(--text-tertiary);">セクター配分</span></div>
            <div id="sector-allocation">Loading...</div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="footer-left">Shadow portfolio for educational purposes only. Not investment advice.<br>Data refreshed daily via automated pipeline. Past performance does not indicate future results.</div>
        <div class="footer-right">自主運用ポートフォリオ</div>
    </footer>

    <script>
    // ══════════════════════════════════════════════════
    // Portfolio Frontend — reads data/portfolio.json
    // ══════════════════════════════════════════════════

    let chartInstance = null;
    let portfolioData = null;

    // ── Utility Functions ──

    function formatCurrency(value) {
        return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }

    function formatPct(value, showSign = true) {
        const sign = value >= 0 ? '+' : '';
        return (showSign ? sign : '') + value.toFixed(2) + '%';
    }

    function setReturnClass(element, value) {
        element.classList.remove('positive', 'negative', 'positive-cell', 'negative-cell');
        if (element.tagName === 'TD') {
            element.classList.add(value >= 0 ? 'positive-cell' : 'negative-cell');
        } else {
            element.classList.add(value >= 0 ? 'positive' : 'negative');
        }
    }

    // ── Summary Section ──

    function renderSummary(data) {
        const s = data.summary;

        // Portfolio value
        document.getElementById('portfolio-value').textContent = formatCurrency(s.portfolio_value);

        // Return badge
        const returnEl = document.getElementById('portfolio-return');
        returnEl.textContent = formatPct(s.total_return) + ' since inception';
        setReturnClass(returnEl, s.total_return);

        // Meta line
        document.getElementById('portfolio-meta').textContent =
            `Inception: ${data.inception_date} · Last updated: ${data.last_updated} · Starting capital: ${formatCurrency(data.starting_capital)}`;
    }

    // ── Stats Row ──

    function renderStats(data) {
        const s = data.summary;

        // YTD
        const ytdEl = document.getElementById('stat-ytd');
        ytdEl.textContent = formatPct(s.ytd_return);
        setReturnClass(ytdEl, s.ytd_return);

        // YTD benchmark comparison
        const nikkeiReturn = data.benchmarks['Nikkei 225'] ? data.benchmarks['Nikkei 225'].current : null;
        document.getElementById('stat-ytd-bench').textContent =
            nikkeiReturn !== null ? `vs. Nikkei 225 ${formatPct(nikkeiReturn)}` : '';

        // Sharpe
        document.getElementById('stat-sharpe').textContent = s.sharpe_ratio.toFixed(2);

        // Max drawdown
        const ddEl = document.getElementById('stat-drawdown');
        ddEl.textContent = formatPct(s.max_drawdown, false);
        setReturnClass(ddEl, s.max_drawdown);
        document.getElementById('stat-drawdown-date').textContent = s.max_drawdown_date;

        // Positions
        document.getElementById('stat-positions').textContent = s.positions_count;
        document.getElementById('stat-positions-breakdown').textContent =
            `${s.jp_count} JP · ${s.us_count} US`;

        // Cash
        document.getElementById('stat-cash-pct').textContent = s.cash_pct.toFixed(1) + '%';
        document.getElementById('stat-cash-usd').textContent = formatCurrency(s.cash_usd);
    }

    // ── Holdings Table ──

    function renderHoldings(data) {
        const tbody = document.getElementById('holdings-body');
        const holdings = data.holdings;

        document.getElementById('holdings-count').textContent = `${holdings.length} positions`;

        if (holdings.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align:center; color:var(--text-tertiary); padding:2rem;">No positions yet</td></tr>';
            return;
        }

        tbody.innerHTML = holdings.map(h => `
            <tr>
                <td>
                    <div class="ticker">${h.ticker}</div>
                    <div class="company-name">${h.company_name}</div>
                </td>
                <td><span class="tag">${h.sector}</span></td>
                <td>${h.weight.toFixed(1)}%</td>
                <td>${h.display_cost}</td>
                <td>${h.display_current}</td>
                <td class="${h.return_pct >= 0 ? 'positive-cell' : 'negative-cell'}">${formatPct(h.return_pct)}</td>
            </tr>
        `).join('');
    }

    // ── Allocation Bars ──

    function renderAllocations(data) {
        const alloc = data.allocations;

        // Geography
        const geoContainer = document.getElementById('geo-allocation');
        geoContainer.innerHTML = renderBarGroups(alloc.geography);

        // Sector
        const sectorContainer = document.getElementById('sector-allocation');
        sectorContainer.innerHTML = renderBarGroups(alloc.sector);
    }

    function renderBarGroups(items) {
        const entries = Object.entries(items);
        const maxVal = Math.max(...entries.map(([, v]) => v));

        return entries.map(([label, value], i) => {
            const opacity = label === 'Cash'
                ? 'background:var(--text-tertiary); opacity:0.3'
                : `opacity:${Math.max(0.35, 1 - (i * 0.15))}`;

            return `
                <div class="alloc-bar-group">
                    <div class="alloc-bar-label">
                        <span>${label}</span>
                        <span>${value.toFixed(1)}%</span>
                    </div>
                    <div class="alloc-bar-track">
                        <div class="alloc-bar-fill" style="width:${value}%; ${opacity}"></div>
                    </div>
                </div>
            `;
        }).join('');
    }

    // ── Performance Chart ──

    function renderChart(data, range = 'all') {
        const chart = data.chart;
        const dates = chart.dates;
        const portfolio = chart.portfolio;
        const nikkei = chart['Nikkei 225'] || [];
        const sp500 = chart['S&P 500'] || [];

        // Filter by time range
        let startIdx = 0;
        if (range !== 'all' && dates.length > 0) {
            const now = new Date(dates[dates.length - 1]);
            let cutoff;
            switch (range) {
                case '1m': cutoff = new Date(now.setMonth(now.getMonth() - 1)); break;
                case '3m': cutoff = new Date(now.setMonth(now.getMonth() - 3)); break;
                case '6m': cutoff = new Date(now.setMonth(now.getMonth() - 6)); break;
                case '1y': cutoff = new Date(now.setFullYear(now.getFullYear() - 1)); break;
                default: cutoff = new Date(dates[0]);
            }
            startIdx = dates.findIndex(d => new Date(d) >= cutoff);
            if (startIdx < 0) startIdx = 0;
        }

        const filteredDates = dates.slice(startIdx);
        const filteredPortfolio = portfolio.slice(startIdx);
        const filteredNikkei = nikkei.slice(startIdx);
        const filteredSP = sp500.slice(startIdx);

        // Format date labels
        const labels = filteredDates.map(d => {
            const date = new Date(d);
            return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
        });

        // Remove duplicate consecutive labels for cleaner axis
        const cleanLabels = labels.map((label, i) => {
            if (i === 0 || label !== labels[i - 1]) return label;
            return '';
        });

        if (chartInstance) {
            chartInstance.destroy();
        }

        const ctx = document.getElementById('performanceChart').getContext('2d');
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: cleanLabels,
                datasets: [
                    {
                        label: 'Portfolio',
                        data: filteredPortfolio,
                        borderColor: '#2D5A3D',
                        backgroundColor: 'rgba(45,90,61,0.04)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        pointHoverBackgroundColor: '#2D5A3D',
                    },
                    {
                        label: 'Nikkei 225',
                        data: filteredNikkei,
                        borderColor: '#C4C4C4',
                        borderWidth: 1.5,
                        borderDash: [4, 3],
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 3,
                    },
                    {
                        label: 'S&P 500',
                        data: filteredSP,
                        borderColor: '#D4C4A8',
                        borderWidth: 1.5,
                        borderDash: [4, 3],
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 3,
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1A1A1A',
                        titleFont: { family: 'DM Sans', size: 11, weight: '400' },
                        bodyFont: { family: 'DM Sans', size: 11 },
                        padding: 10,
                        cornerRadius: 2,
                        displayColors: true,
                        boxWidth: 8,
                        boxHeight: 2,
                        callbacks: {
                            label: function(context) {
                                return ' ' + context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { display: false },
                        ticks: {
                            font: { family: 'DM Sans', size: 10, weight: '400' },
                            color: '#9B9B9B',
                            padding: 8,
                            maxTicksLimit: 12,
                        },
                        border: { display: false },
                    },
                    y: {
                        grid: { color: 'rgba(0,0,0,0.04)', drawBorder: false },
                        ticks: {
                            font: { family: 'DM Sans', size: 10, weight: '400' },
                            color: '#9B9B9B',
                            padding: 12,
                            callback: function(value) { return value + '%'; }
                        },
                        border: { display: false },
                    }
                }
            }
        });
    }

    // ── Time Filter Buttons ──

    function initTimeFilters() {
        document.querySelectorAll('.time-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (portfolioData) {
                    renderChart(portfolioData, btn.dataset.range);
                }
            });
        });
    }

    // ── Load and Render ──

    async function init() {
        initTimeFilters();

        try {
            const response = await fetch('data/portfolio.json');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            portfolioData = await response.json();

            renderSummary(portfolioData);
            renderStats(portfolioData);
            renderHoldings(portfolioData);
            renderAllocations(portfolioData);
            renderChart(portfolioData, '1y');

        } catch (error) {
            console.error('Failed to load portfolio data:', error);
            document.getElementById('portfolio-value').textContent = '—';
            document.getElementById('portfolio-meta').textContent =
                'Portfolio data unavailable. Run the pipeline to generate data/portfolio.json';
        }
    }

    init();
    </script>

</body>
</html>
